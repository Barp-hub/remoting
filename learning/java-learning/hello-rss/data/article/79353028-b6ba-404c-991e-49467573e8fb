<p>最近发现一个应用每次跑了6-10个小时之后就挂起，不处理任何请求。 jstack线程日志发现大量的如下等待<br />
<span id="more-1983"></span></p>
<blockquote><p>&#8220;http-nio-18080-exec-296&#8243; #1248854 daemon prio=5 os_prio=0 tid=0x000000005cfe7800 nid=0x10c40 waiting on condition [0x000000007babd000]<br />
   java.lang.Thread.State: WAITING (parking)<br />
	at sun.misc.Unsafe.park(Native Method)<br />
	&#8211; parking to wait for  <0x00000000c1db22d8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)<br />
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)<br />
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)<br />
	at org.apache.tomcat.dbcp.pool2.impl.LinkedBlockingDeque.takeFirst(LinkedBlockingDeque.java:586)<br />
	at org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:438)<br />
	at org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:359)<br />
	at org.apache.tomcat.dbcp.dbcp2.PoolingDataSource.getConnection(PoolingDataSource.java:134)<br />
	at org.apache.tomcat.dbcp.dbcp2.BasicDataSource.getConnection(BasicDataSource.java:1543)<br />
	at org.springframework.jdbc.datasource.DataSourceUtils.doGetConnection(DataSourceUtils.java:111)<br />
	at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:77)<br />
	at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:575)<br />
	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:639)<br />
	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:664)
</p></blockquote>
<p>因为数据库数据源时JNDI配置， 默认连接池用的是dbcp2，应该是连接耗尽，产生了饥饿死，下面是DBCP的一些弊端 </p>
<p><a href="https://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html">https://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html</a></p>
<p>The JDBC Connection Pool org.apache.tomcat.jdbc.pool is a replacement or an alternative to the Apache Commons DBCP connection pool.</p>
<p>So why do we need a new connection pool?</p>
<blockquote><p> Commons DBCP 1.x is single threaded. In order to be thread safe Commons locks the entire pool for short periods during both object allocation and object return. Note that this does not apply to Commons DBCP 2.x.<br />
Commons DBCP 1.x can be slow. As the number of logical CPUs grows and the number of concurrent threads attempting to borrow or return objects increases, the performance suffers. For highly concurrent systems the impact can be significant. Note that this does not apply to Commons DBCP 2.x.<br />
Commons DBCP is over 60 classes. tomcat-jdbc-pool core is 8 classes, hence modifications for future requirement will require much less changes. This is all you need to run the connection pool itself, the rest is gravy.<br />
Commons DBCP uses static interfaces. This means you have to use the right version for a given JRE version or you may see NoSuchMethodException exceptions.<br />
It&#8217;s not worth rewriting over 60 classes, when a connection pool can be accomplished with a much simpler implementation.<br />
Tomcat jdbc pool implements the ability retrieve a connection asynchronously, without adding additional threads to the library itself.<br />
Tomcat jdbc pool is a Tomcat module, it depends on Tomcat JULI, a simplified logging framework used in Tomcat.<br />
Retrieve the underlying connection using the javax.sql.PooledConnection interface.<br />
Starvation proof. If a pool is empty, and threads are waiting for a connection, when a connection is returned, the pool will awake the correct thread waiting. Most pools will simply starve.</p>
</blockquote>
<p>官方建议用tomcat jdbc， 改成这个之后果然好了</p>
